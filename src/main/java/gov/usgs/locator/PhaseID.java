package gov.usgs.locator;

import gov.usgs.traveltime.AuxTtRef;
import gov.usgs.traveltime.TTSessionLocal;
import gov.usgs.traveltime.TTime;
import gov.usgs.traveltime.TTimeData;
import gov.usgs.traveltime.TauUtil;
import java.util.ArrayList;

/**
 * The PhaseID class associates theoretical seismic phases with the observed  
 * seismicpicks.
 *
 * @author Ray Buland
 *
 */
public class PhaseID {
  /**
   * An Event object containing the event to perform phase identification upon.
   */
  private Event event;

  /**
   * A Hypocenter object containing the hypocenter of event to perform phase 
   * identification upon.
   */  
  private Hypocenter hypo;

  /**
   * A TTSessionLocal object containing a local travel-time manager used to  
   * perform phase identification.
   */    
  private TTSessionLocal ttLocalSession;
 
  /**
   * An AuxTtRef object containing a auxiliary travel-time information used to  
   * perform phase identification.
   */     
  private AuxTtRef auxiliaryTTInfo;

  /** 
   * An ArrayList of Wresidual objects containing the weighted residuals of the 
   * event picks.
   */  
  private ArrayList<Wresidual> weightedResiduals;

  /**
   * A PickGroup object, which holds the current pick group being processed by 
   * phaseID.
   */
  private PickGroup currentGroup;

  /**
   * A Pick object containing the last pick identified.
   */ 
  private Pick lastPick = null;

  /**
   * A TTime object containing the travel time information for all possible
   * phases generated by a source at the event to the current pick group
   * being processed by phaseID.
   */
  private TTime currentTTList = null;

  /**
   * A double containing the weight for phases that don't match, used to 
   * control figure-of-merit calculations during phaseID.
   */
  private double otherWeight;      

  /**
   * A double containing the weight to resist changing identification, used to 
   * control figure-of-merit calculations during phaseID.
   */  
  private double stickyWeight;

  /** 
   * A boolean flag indicating whether the current phase being identified is 
   * a generic phase or not.
   */
  private boolean isGeneric = false;

  /** 
   * A boolean flag indicating whether the current phase being identified is 
   * a primary phase or not.
   */ 
  private boolean isPrimary = false;

  /**
   * A String containing the last travel time phase group name processed by 
   * phaseID.
   */
  private String currPhaseGroupName = null;

  /**
   * The PhaseID constructor. This constructor sets the event and tt session to 
   * the provided values.
   *
   * @param event An Event object containing the information for the event to 
   *              perform phase identification upon.
   * @param ttLocalSession A TTSessionLocal object holding the local travel-time 
   *                       manager
   */
  public PhaseID(Event event, TTSessionLocal ttLocalSession) {
    this.event = event;
    hypo = event.getHypo();
    this.ttLocalSession = ttLocalSession;

    if (ttLocalSession != null) {
      this.auxiliaryTTInfo = ttLocalSession.getAuxTT();
    } else {
      this.auxiliaryTTInfo = null;
    }

    weightedResiduals = event.getRawWeightedResiduals();
  }

  /**
   * The phaseID function performs the the phase identification on the event.
   *
   * @param otherWeight A double containing the weight for phases that don't 
   *                    match the current phase identification or the current 
   *                    phase group (higher weights make changing to an "other" 
   *                    phase easier)
   * @param stickyWeight A double containing the weight for an exact match 
   *                     (higher weights make changing the current 
   *                     identification harder.
   * @param reidentifyPhases If true, do the full phase re-identification, if 
   *                         false try not to change phase identifications
   * @param reweightResiduals If true, update the residual weights
   * @return True if any used pick in the group has changed significantly
   * @throws Exception On an illegal source depth
   */
  public boolean phaseID(double otherWeight, double stickyWeight, 
      boolean reidentifyPhases, boolean reweightResiduals) throws Exception {
   
    if (LocUtil.deBugLevel > 0) {
      System.out.println("\nCurr loc: " + hypo + "\n");
    }

    // Remember the figure-of-merit controls.
    this.otherWeight = otherWeight;
    this.stickyWeight = stickyWeight;
    
    // Initialize the changed flag.
    boolean changed;
    if (reweightResiduals) {
      changed = true;
    } else {
      changed = false;
    }
    
    // Reinitialize the weighted residual storage.
    if (weightedResiduals.size() > 0) {
      weightedResiduals.clear();
    }

    // Set up a new travel-time session.
    ttLocalSession.newSession(event.getEarthModel(), hypo.getDepth(), 
        LocUtil.PHASELIST, hypo.getLatitude(), hypo.getLongitude(), 
        LocUtil.SUPRESSUNLIKELYPHASES, LocUtil.SUPRESSBACKBRANCHES, 
        LocUtil.isTectonic, false);
        
    // Do the travel-time calculation for each pick group
    for (int j = 0; j < event.getNumStations(); j++) {
      currentGroup = event.getPickGroupList().get(j);
      Station station = currentGroup.getStation();
      
      if (LocUtil.deBugLevel > 1) {
        System.out.format("PhaseID: %-5s %6.2f %6.2f %6.2f\n", 
            station.getStationID().staCode, currentGroup.getPicks().get(0).getTravelTime(), 
            currentGroup.getDistance(), currentGroup.getAzimuth());
      }
      
      // For the first pick in the group, get the travel times.
      currentTTList = ttLocalSession.getTT(station.getLatitude(), station.getLongitude(),
          station.getElevation(), currentGroup.getDistance(), currentGroup.getAzimuth());
      
      // Print them.
      // if (station.getStationID().staCode.equals("TX11")) {
      // currentTTList.print();
      // }
      
      // If reidentifyPhases is true, do a full phase re-identification for the
      // current group.
      // NOTE this is done using class variables rather than just passing the 
      // group in, ick.
      if (reidentifyPhases) {
        reidentifyPhases();
      } else {
        // Otherwise, try not to re-identify the phases.
        noReidentification();
      }

      // update changed flag
      if (currentGroup.updatePhaseIdentifications(reweightResiduals, weightedResiduals)) {
        changed = true;
      }
    }

    // Add the Bayesian depth.
    weightedResiduals.add(new Wresidual(null, hypo.getBayesianDepthResidual(), 
        hypo.getBayesianDepthWeight(), true, 0d, 0d, 1d));
    
    // Save a copy of weightedResiduals in the original order.
    event.saveWeightedResiduals();
    
    // Update the station statistics.
    event.computeStationStats();

    return changed;
  }

  /**
   * This function tries to re-identifys only if the identification is invalid. 
   * During the location iteration, we don't want to re-identify phases, but 
   * sometimes re-identification is thrust upon us (e.g., when the depth or 
   * distance changes and the former identification no longer exists).
   */
  private void noReidentification() {
    // NOTE this depends on the current group being set by phaseID
    // Loop over picks in the group.
    for (int j = 0; j < currentGroup.getNumPicks(); j++) {
      Pick pick = currentGroup.getPick(j);
      String phCode = pick.getCurrentPhaseCode();

      if (!phCode.equals("")) {
        // If we have a non-blank phase code, find the phase of the same name 
        // that is closest to the pick in time.
        int ttIndex = -1;
        double minResidual = TauUtil.DMAX;
        
        for (int i = 0; i < currentTTList.size(); i++) {
          TTimeData travelTime = currentTTList.get(i);
          
          if (phCode.equals(travelTime.getPhCode())) {
            if (Math.abs(pick.getTravelTime() - travelTime.getTT()) < minResidual) {
              ttIndex = i;
              minResidual = Math.abs(pick.getTravelTime() - travelTime.getTT());
            }
          }
        }
        
        // If it's not too out of whack, force the association.
        if (ttIndex >= 0 && (minResidual <= LocUtil.ASSOCTOLERANCE 
            || phCode.equals("Lg") || phCode.equals("LR"))) {
          pick.setTTStatisticalMinFoM(currentTTList.get(ttIndex));
          pick.setStatisticalFoM(minResidual);
          pick.setForceAssociation(true);
          
          if (LocUtil.deBugLevel > 1) { 
            System.out.format("NoReID: got it %-5s %-8s %6.2f %2d\n", 
                pick.getStation().getStationID().staCode, phCode, minResidual, ttIndex);
          }
        } else {
          // If the easy way doesn't work, we have to try harder.
          // If we have a non-blank phase code, find the phase of the same name 
          // that is closest to the pick in time.
          String phaseGroupName = auxiliaryTTInfo.findGroup(phCode, false);
          ttIndex = -1;
          minResidual = TauUtil.DMAX;
          
          for (int i = 0; i < currentTTList.size(); i++) {
            TTimeData travelTime = currentTTList.get(i);
            
            if (phaseGroupName.equals(travelTime.getPhGroup())) {
              if (Math.abs(pick.getTravelTime() - travelTime.getTT()) < minResidual) {
                ttIndex = i;
                minResidual = Math.abs(pick.getTravelTime() - travelTime.getTT());
              }
            }
          }
          
          // If it's not too out of whack, force the association.
          if (ttIndex >= 0 && minResidual <= LocUtil.ASSOCTOLERANCE) {
            pick.setTTStatisticalMinFoM(currentTTList.get(ttIndex));
            pick.setStatisticalFoM(minResidual);
            pick.setForceAssociation(true);
            
            if (LocUtil.deBugLevel > 1) {
              System.out.format("NoReID: group %-5s %-8s -> %-8s %6.2f %2d\n", 
                  pick.getStation().getStationID().staCode, phCode, 
                  currentTTList.get(ttIndex).getPhCode(), minResidual, ttIndex);
            }
          } else {
            if (pick.getIsUsed()) {
              if (LocUtil.deBugLevel > 1) {
                System.out.println("NoReID: give up " 
                    + pick.getStation().getStationID().staCode);
              }

              currentGroup.initializeFoM(j, j);
              reidentifyPhases();
            } else {
              pick.setTTStatisticalMinFoM(null);
            }
          }
        } // end else phase out of wack
      } // end if phase code blank
    } // end loop over picks in the group.
  }

  /**
   * This more sophisticated phase identification is used once we have a 
   * decent initial location.  Note that for a full phase re-identification 
   * the weights are always updated.
   */
  private void reidentifyPhases() {
    // Initialize the figure-of-merit memory.
    currentGroup.initializeFoM(0, currentGroup.getNumPicks());
    
    // Pre-identify surface waves identified by trusted sources.
    for (int j = 0; j < currentGroup.getNumPicks(); j++) {
      Pick pick = currentGroup.getPick(j);

      if (pick.getIsSurfaceWave()) {
        for (int i = 0; i < currentTTList.size(); i++) {
          if (pick.getBestPhaseCode().equals(currentTTList.get(i).getPhCode())) {
            pick.setTTStatisticalMinFoM(currentTTList.get(i));
            pick.setForceAssociation(true);
            break;
          }
        }
      }
    }
    
    // Split the theoretical phase into clusters (groups isolated in 
    // travel time).
    if (LocUtil.deBugLevel > 1) {
      System.out.println("\n\tClusters:");
    }

    int i = 0;
    TTimeData travelTime = currentTTList.get(0);
    double minTTWindow = travelTime.getTT() - travelTime.getWindow();
    double maxTTWindow = travelTime.getTT() + travelTime.getWindow();
    int firstTTIndex = 0; // Index of the first theoretical arrival
    int numTT = 1; // Number of theoretical arrivals
    int firstPhaseIndex = -1; // Index of the first phase within this phase group
    int numPicks = 0; // Number of picks 

    // Loop over theoretical arrivals.
    for (int j = 1; j < currentTTList.size(); j++) {
      travelTime = currentTTList.get(j);
      
      // If this is part of the same cluster, extend the window.
      if (travelTime.getTT() - travelTime.getWindow() <= maxTTWindow) {
        minTTWindow = Math.min(minTTWindow, travelTime.getTT() - travelTime.getWindow());
        maxTTWindow = Math.max(maxTTWindow, travelTime.getTT() + travelTime.getWindow());
        numTT++;
      } else {
        // This theoretical cluster is done, now associate picks within 
        // the current pick group.
        for (; i < currentGroup.getNumPicks(); i++) {
          Pick pick = currentGroup.getPick(i);

          if (pick.getTravelTime() <= maxTTWindow) {
            if (pick.getTravelTime() >= minTTWindow) {
              if (numPicks == 0) {
                firstPhaseIndex = i;
              }
              numPicks++;
            }
          } else {
            break;
          }
        }

        // If this cluster has picks, do the identification.
        if (numPicks > 0) {
          // Print the current cluster.
          if (LocUtil.deBugLevel > 1) {
            System.out.format("TT: %2d %2d  Pick: %2d %2d  Win: %7.2f %7.2f\n", 
                firstTTIndex, numTT, firstPhaseIndex, numPicks, minTTWindow, 
                maxTTWindow);
          }

          // Initialize the cumulative figure-of-merit.
          currentGroup.setCumulativeFoM(0d);
          
          // Do the identification.
          genPhasePermutations(firstPhaseIndex, numPicks, firstTTIndex, numTT);
        }

        // Quit if we're out of picks.
        if (i >= currentGroup.getNumPicks()) {
          break;
        }

        // Otherwise, set up for the next cluster.
        minTTWindow = travelTime.getTT() - travelTime.getWindow();
        maxTTWindow = travelTime.getTT() + travelTime.getWindow();
        firstTTIndex = j;
        numTT = 1;
        firstPhaseIndex = -1;
        numPicks = 0;
      }
    }

    // Apply the distance correction to the first arriving phase.
    double distanceCorrection = LocUtil.computeDistCorr(currentGroup.getDistance());
    if (distanceCorrection > 1d) {
      if (currentGroup.getPick(0).getTTStatisticalMinFoM() != null) {
        currentGroup.getPick(0).setStatisticalFoM(
            currentGroup.getPick(0).getStatisticalFoM() / distanceCorrection);
      }

      if (currentGroup.getPick(0).getTTAlternateMinFoM() != null) {
        currentGroup.getPick(0).setAlternateFoM(
            currentGroup.getPick(0).getAlternateFoM() / distanceCorrection);
      }
    }
    
    // Print out the chosen associations.
    if (LocUtil.deBugLevel > 2) { 
      printAssoc();
    }
    
    // Finally, rationalize the two identification methods.
    fomMerge();
  }
  
  /**
   * This function prints out the chosen associations. This can be messy because 
   * of possible null pointers.
   */
  private void printAssoc() {
    for (int j = 0; j < currentGroup.getNumPicks(); j++) {
      Pick pick = currentGroup.getPick(j);
      
      if (pick.getTTStatisticalMinFoM() != null) {
        if (pick.getTTAlternateMinFoM() != null) {
          System.out.format("  Sel: %1d %-8s %-8s %5.2f %5.2f\n", j, 
              pick.getTTStatisticalMinFoM().getPhCode(), pick.getTTAlternateMinFoM().getPhCode(), pick.getStatisticalFoM(), 
              pick.getAlternateFoM());
        } else {
          System.out.format("  Sel: %1d %-8s null     %5.2f\n", j, 
              pick.getTTStatisticalMinFoM().getPhCode(), pick.getStatisticalFoM());
        }
      } else {
        if (pick.getTTAlternateMinFoM() != null) {
          System.out.format("  Sel: %1d null     %-8s       %5.2f\n", j, 
              pick.getTTAlternateMinFoM().getPhCode(), pick.getAlternateFoM());
        } else {
          System.out.format("  Sel: %1d null     null\n", j);
        }
      }
    }
  }
  
  /**
   * This function merges the statistical and nearest theoretical phase 
   * identification strategies.  This code has been isolated in the hope that a 
   * Bayesian approach will eliminate the alternate phase identification.
   */
  private void fomMerge() {
    for (int j = 0; j < currentGroup.getNumPicks(); j++) {
      Pick pick = currentGroup.getPick(j);
      
      // The identification will be done using the statistical variables.  
      // Therefore, we only need to change the statistical variables if the 
      // alternative identification looks better.
      if (pick.getTTStatisticalMinFoM() != null) {
        if (pick.getTTAlternateMinFoM() != null) {
          // We have both, now what?
          if (j == 0) {
            // Favor the alternate identification for the first arrival.
            if (pick.getAlternateFoM() <= 2d 
                * LocUtil.computeValidityLimit(pick.getTTAlternateMinFoM().getSpread())  
                && pick.getAlternateFoM() < pick.getStatisticalFoM() - 1d && pick.getTTAlternateMinFoM().getPhGroup()
                == pick.getTTStatisticalMinFoM().getPhGroup()) {
              pick.setTTStatisticalMinFoM(pick.getTTAlternateMinFoM());
              pick.setStatisticalFoM(pick.getAlternateFoM());
            // If that didn't work, see if the statistical identification is 
            // acceptable.
            } else if (pick.getStatisticalFoM() > 2d 
                * LocUtil.computeValidityLimit(pick.getTTStatisticalMinFoM().getSpread())) {
              // If that that didn't work, go back to the alternate 
              // identification.
              if (pick.getAlternateFoM() <= 2d 
                  * LocUtil.computeValidityLimit(pick.getTTAlternateMinFoM().getSpread())) {
                pick.setTTStatisticalMinFoM(pick.getTTAlternateMinFoM());
                pick.setStatisticalFoM(pick.getAlternateFoM());
              } else {
                // If all else fails, give up.
                pick.setTTStatisticalMinFoM(null);
              }
            }
          // Treat later phases differently.
          } else {
            // Favor the alternate identification, but not quite as strictly.
            if (pick.getAlternateFoM() <= 2d 
                * LocUtil.computeValidityLimit(pick.getTTAlternateMinFoM().getSpread())
                && pick.getAlternateFoM() < pick.getStatisticalFoM() - 0.5d) {
              pick.setTTStatisticalMinFoM(pick.getTTAlternateMinFoM());
              pick.setStatisticalFoM(pick.getAlternateFoM());
            } else if (pick.getStatisticalFoM() > 2d 
                * LocUtil.computeValidityLimit(pick.getTTStatisticalMinFoM().getSpread())) {
              // If that that didn't work, go back to the alternate 
              // identification.
              if (pick.getAlternateFoM() <= 2d 
                  * LocUtil.computeValidityLimit(pick.getTTAlternateMinFoM().getSpread())) {
                pick.setTTStatisticalMinFoM(pick.getTTAlternateMinFoM());
                pick.setStatisticalFoM(pick.getAlternateFoM());
              } else {
                // If all else fails, give up.
                pick.setTTStatisticalMinFoM(null);
              }
            }
          }
        // We only have a statistical identification.
        } else if (pick.getStatisticalFoM() > 2d 
            * LocUtil.computeValidityLimit(pick.getTTStatisticalMinFoM().getSpread())) {
          pick.setTTStatisticalMinFoM(null);
        }
      // We don't have a statistical identification, try the alternative.
      } else if (pick.getTTAlternateMinFoM() != null) {
        if (pick.getAlternateFoM() <= 2d 
            * LocUtil.computeValidityLimit(pick.getTTAlternateMinFoM().getSpread())) {
          pick.setTTStatisticalMinFoM(pick.getTTAlternateMinFoM());
          pick.setStatisticalFoM(pick.getAlternateFoM());
        } else {
          pick.setTTStatisticalMinFoM(null);
        }
      // Neither method found a match.  Give up.
      } else {
        pick.setTTStatisticalMinFoM(null);
      }
    }
    
    // We're not quite done.  Now we need to eliminate duplicate 
    // identifications.
    for (int j = 0; j < currentGroup.getNumPicks() - 1; j++) {
      Pick pick = currentGroup.getPick(j);
      
      if (pick.getTTStatisticalMinFoM() != null) {
        for (int i = j + 1; i < currentGroup.getNumPicks(); i++) {
          Pick pick2 = currentGroup.getPick(i);
          
          if (pick.getTTStatisticalMinFoM() == pick2.getTTStatisticalMinFoM()) {
            if (j == 0) {
              pick2.setTTStatisticalMinFoM(null);
            } else {
              // The alternative figure-of-merits have to exist for this 
              // problem to occur.
              if (pick.getStatisticalFoM() <= pick2.getStatisticalFoM()) {
                pick2.setTTStatisticalMinFoM(null);
              } else {
                pick.setTTStatisticalMinFoM(null);
                break;
              }
            }
          }
        }
      }
    }
    
    // Sometimes the arrival order of the picks and the order of the 
    // theoretical phases are at odds.  If we leave it, it can cause problems, 
    // so, just delete one of the identifications.
    Pick pick2 = currentGroup.getPick(0);
    for (int j = 1; j < currentGroup.getNumPicks(); j++) {
      Pick pick = pick2;
      pick2 = currentGroup.getPick(j);
      
      if (pick.getTTStatisticalMinFoM() != null && pick2.getTTStatisticalMinFoM() != null) {
        if (pick.getTTStatisticalMinFoM().getTT() > pick2.getTTStatisticalMinFoM().getTT()) {
          if (pick.getTTStatisticalMinFoM().getObserv() >= pick2.getTTStatisticalMinFoM().getObserv()) {
            // Apparently, we don't care if Lg or LR are out of order.
            if (!pick2.getTTStatisticalMinFoM().getPhCode().equals("Lg")  
                && !pick2.getTTStatisticalMinFoM().getPhCode().equals("LR")) {
              pick2.setTTStatisticalMinFoM(null);
            }
          } else {
            if (!pick.getTTStatisticalMinFoM().getPhCode().equals("Lg")  
                && !pick.getTTStatisticalMinFoM().getPhCode().equals("LR")) {
              pick.setTTStatisticalMinFoM(null);
            }
          }
        }
      }
    }
  }

  /**
   * This function generates combinations of picks or theoretical arrivals to 
   * compare with all possible combinations of theoretical arrivals or picks. 
   * For example, if there are 3 picks and 5 theoretical arrivals, the 
   * theoretical arrivals will be taken 3 at a time until all possible 
   * combinations in the original order have been generated. Each combination 
   * will be treated as a trial phase identification of the picks to those 
   * theoretical arrivals.
   *
   * @param firstPhaseIndex An int containing the index of the first phase 
   *                        within this phase group that will be part of this 
   *                        phase identification
   * @param numPicks An int holding the number of picks to include in this phase 
   *                 identification
   * @param firstTTIndex An int containing the index of the first theoretical 
   *                     arrival that will be part of this phase identification
   * @param numTT An int holding the number of theoretical arrivals to include 
   *              in this phase identification
   */
  private void genPhasePermutations(int firstPhaseIndex, int numPicks, 
      int firstTTIndex, int numTT) {
    // Set up some pointer arrays to work with internally.
    Pick[] obsPicks = new Pick[numPicks];
    for (int j = 0, i = firstPhaseIndex; j < numPicks; j++, i++) {
      obsPicks[j] = currentGroup.getPicks().get(i);
    }

    TTimeData[] ttArrivals = new TTimeData[numTT];
    for (int j = 0, i = firstTTIndex; j < numTT; j++, i++) {
      ttArrivals[j] = currentTTList.get(i);
    }

    if (LocUtil.deBugLevel > 1) {
      System.out.format("\n Permut: %2d Picks, %2d TTs\n", numPicks, numTT);
    }

    // The algorithm depends on which group is the most numerous.
    if (numTT >= numPicks) {
      // Generate the combinations.
      TTimeData[] ttPermutation = new TTimeData[numPicks];
      genKPermutationsOfN(ttArrivals, numPicks, 0, ttPermutation, obsPicks);
    } else {
      // Generate the combinations.
      Pick[] pickPermutation = new Pick[numTT];
      genKPermutationsOfN(obsPicks, numTT, 0, pickPermutation, ttArrivals);
    }
  }

  /**
   * This function creates all k-permutations of n objects, where k is the 
   * length of ttPermutation and n is the length of ttGrp. Note that this  
   * algorithm is recursive. The variables length and startIndex are primarily 
   * for internal use. For the caller, length should be the length of the result 
   * (ttPermutation) and startIndex should be 0. This algorithm has been taken 
   * from StackOverflow. It was posted by user935714 on 20 April 2016.
   *
   * @param ttArrivals A TTimeData[] containing an array of the theoretical 
   *                   arrivals
   * @param length An int containing the the length of the permutation subset
   * @param startIndex An int containing the starting index of the permutation 
   *                   subset
   * @param ttPermutation A TTimeData[] containing the results of the 
   *                      permutation
   * @param obsPicks A Pick[] containing the array of observed picks
   */
  private void genKPermutationsOfN(TTimeData[] ttArrivals, int length, int startIndex, 
      TTimeData[] ttPermutation, Pick[] obsPicks) {
    if (length == 0) {
      computeCombinedFoM(obsPicks, ttPermutation);
      return;
    }

    for (int i = startIndex; i <= ttArrivals.length - length; i++) {
      ttPermutation[ttPermutation.length - length] = ttArrivals[i];
      genKPermutationsOfN(ttArrivals, length - 1, i + 1, ttPermutation, 
          obsPicks);
    }
  }

  /**
   * This function creates all k-permutations of n objects, where k is the length  
   * of pickPermutation and n is the length of pickGrp. Note that this algorithm  
   * is recursive. The variables length and startIndex are primarily for internal 
   * use. For the caller, length should be the length of the result 
   * (pickPermutation) and startIndex should be 0. This algorithm has been taken 
   * from StackOverflow. It was posted by user935714 on 20 April 2016.
   *
   * @param obsPicks A Pick[] containing the array of observed picks
   * @param length An int containing the the length of the permutation subset
   * @param startIndex An int containing the starting index of the permutation 
   *                   subset
   * @param pickPermutation A Pick[] containing the results of the permutation
   * @param ttArrivals A TTimeData[] containing an array of the theoretical 
   *                   arrivals
   */
  private void genKPermutationsOfN(Pick[] obsPicks, int length, int startIndex, 
      Pick[] pickPermutation, TTimeData[] ttArrivals) {
    if (length == 0) {
      computeCombinedFoM(pickPermutation, ttArrivals);
      return;
    }

    for (int i = startIndex; i <= obsPicks.length - length; i++) {
      pickPermutation[pickPermutation.length - length] = obsPicks[i];
      genKPermutationsOfN(obsPicks, length - 1, i + 1, pickPermutation, 
          ttArrivals);
    }
  }

  /**
   * This function computes the combined figure(s)-of-merit and saves the best
   * identification results in the picks for later processing for each trial set 
   * of phase identifications.
   *
   * @param obsPicks A Pick[] containing the array of observed picks
   * @param ttArrivals A TTimeData[] containing an array of the theoretical 
   *                   arrivals
   */
  private void computeCombinedFoM(Pick[] obsPicks, TTimeData[] ttArrivals) {
    // Make a pass computing the cumulative statistical figure-of-merit.
    double cumulativeFoM = 1d;
    for (int j = 0; j < ttArrivals.length; j++) {
      if (!obsPicks[j].getIsSurfaceWave()) {
        // Compute the figure-of-merit for the primary criteria.
        double probability = LocUtil.computePDFResValue(obsPicks[j].getTravelTime() 
            - ttArrivals[j].getTT(), 0d, ttArrivals[j].getSpread());
        double observabilityAmp = computeObsAmplitude(obsPicks[j], ttArrivals[j]);
        double residual = computeResidual(obsPicks[j], ttArrivals[j]);
        
        if (LocUtil.deBugLevel > 1) {
          System.out.format("\t%8s %8s: %10.4e %10.4e\n", obsPicks[j].getBestPhaseCode(),
              ttArrivals[j].getPhCode(), probability, observabilityAmp);
        }

        cumulativeFoM *= observabilityAmp * probability;
        
        // Set up the alternative criteria at the same time.  Note, the 
        // Fortran version omitted the affinity in this test.
        if (ttArrivals[j].getObserv() >= LocUtil.OBSERVABILITYMIN && residual 
            < obsPicks[j].getAlternateFoM()) {
          // Make sure that the phase types match unless the pick is automatic.
          if (obsPicks[j].getIsAutomatic() || TauUtil.arrivalType(obsPicks[j].getBestPhaseCode())
              == TauUtil.arrivalType(ttArrivals[j].getPhCode())) {
            obsPicks[j].setAlternateFoM(ttArrivals[j], residual);
            
            if (LocUtil.deBugLevel > 1) {
              System.out.format("\t\tAlt: %4.2f\n", residual);
            }
          }
        }
      }
    }
    
    if (LocUtil.deBugLevel > 2) {
      System.out.format("\tCum: %10.4e %10.4e\n", cumulativeFoM, currentGroup.getCumulativeFoM());
    }

    // Make a second pass if this is the highest figure-of-merit yet.  Note, 
    // the Fortran version has greater than or equal to.
    if (cumulativeFoM > currentGroup.getCumulativeFoM()) {
      currentGroup.setCumulativeFoM(cumulativeFoM);
      
      for (int j = 0; j < ttArrivals.length; j++) {
        if (!obsPicks[j].getIsSurfaceWave()) {
          obsPicks[j].setStatisticalFoM(ttArrivals[j], computeResidual(obsPicks[j], 
              ttArrivals[j]));
        }
      }
    }
  }

  /**
   * This function computes the modified theoretical phase "amplitude". This is 
   * the phase observability with empirical modifiers to reflect how closely it  
   * matches the observed phase. Note that this is a complicated function of who 
   * identified the observed phase, if they are in the same phase group, and 
   * if they have the same phase type. The sticky weight promotes stability by 
   * tending to keep the old identification all else being equal.
   *
   * @param pick A Pick object containing the pick information for one pick
   * @param travelTime A TTimeData object holding arrival time information for one 
   *              arrival
   * @return A double containing the "amplitude" or observability which has been
   *         modified by empirical weights
   */
  private double computeObsAmplitude(Pick pick, TTimeData travelTime) {
    // Set up the observed pick phase group.
    // Note depends on the lastPick class varible being set
    if (pick != lastPick) {
      lastPick = pick;
      currPhaseGroupName = auxiliaryTTInfo.findGroup(pick.getBestPhaseCode(), 
          (pick.getOriginalAuthorType() == AuthorType.CONTRIB_AUTO));
      isPrimary = auxiliaryTTInfo.isPrimary();

      if (currPhaseGroupName.equals("Any") 
          || pick.getBestPhaseCode().equals(currPhaseGroupName)) {
        isGeneric = true;
      } else {
        isGeneric = false;
      }

      if (LocUtil.deBugLevel > 2) {
        System.out.print("New " + currPhaseGroupName);
        if (isPrimary) {
          System.out.print(" Pri");
        }
        if (isGeneric) {
          System.out.print(" Gen");
        }
      }
    } else {
      if (LocUtil.deBugLevel > 2) { 
        System.out.print("Old");
      }
    }

    // initialize the observability amplitude.
    double observabilityAmp;
    if (!travelTime.getDis()) {
      observabilityAmp = travelTime.getObserv();
    } else {
      observabilityAmp = LocUtil.DOWNWEIGHT * travelTime.getObserv();
      if (LocUtil.deBugLevel > 2) {
        System.out.print(" Down");
      }
    }

    // Do the group logic.  If the phase codes match drop through 
    // unless the phase might be generic.
    if ((!pick.getBestPhaseCode().equals(travelTime.getPhCode()) || isGeneric)
            && !currPhaseGroupName.equals("Any")) {
      // Handle primary groups differently for generic phase codes.
      if (isGeneric && isPrimary) {
        // If the observed phase group matches the primary or auxiliary 
        // groups of the theoretical phase use the group weighting.  That 
        // is, a generic P might be either a P or a PKP.  The "Reg" group
        // is a special case for contributed automatic picks (typically 
        // from regional networks) which are assumed to be regional.
        if (currPhaseGroupName.equals(travelTime.getPhGroup())
            || currPhaseGroupName.equals(travelTime.getAuxGroup()) 
            || (currPhaseGroupName.equals("Reg") && travelTime.isRegional())) {
          observabilityAmp *= LocUtil.GROUPWEIGHT;

          if (LocUtil.deBugLevel > 2) {
            System.out.print(" Group1");
          }
        } else {
          // Otherwise use the other (non-group) weighting.
          observabilityAmp *= otherWeight;

          if (LocUtil.deBugLevel > 2) {
            System.out.print(" Other1");
          }

          // If we trust the phase identification and the arrival types 
          // of the phases don't match, make re-identifying even harder
          if (!pick.getIsAutomatic() && TauUtil.arrivalType(currPhaseGroupName)
              != TauUtil.arrivalType(travelTime.getPhCode())) {
            observabilityAmp *= LocUtil.TYPEWEIGHT;

            if (LocUtil.deBugLevel > 2) {
              System.out.print(" Type1");
            }
          }
        }
      } else {
        // If the observed phase group matches the primary group of the 
        // theoretical phase use the group weighting.  That is, a Pn would 
        // be in the same group as Pg, but not PKPdf.  Note that a generic 
        // PKP would only match PKP phases.
        if (currPhaseGroupName.equals(travelTime.getPhGroup())) {
          observabilityAmp *= LocUtil.GROUPWEIGHT;

          if (LocUtil.deBugLevel > 2) {
            System.out.print(" Group2");
          }
        } else {
          // Otherwise use the other (non-group) weighting.
          observabilityAmp *= otherWeight;

          if (LocUtil.deBugLevel > 2) {
            System.out.print(" Other2");
          }

          // If we trust the phase identification and the arrival types 
          // of the phases don't match, make re-identifying even harder
          if (!pick.getIsAutomatic() && TauUtil.arrivalType(currPhaseGroupName)
                  != TauUtil.arrivalType(travelTime.getPhCode())) {
            observabilityAmp *= LocUtil.TYPEWEIGHT;

            if (LocUtil.deBugLevel > 2) {
              System.out.print(" Type2");
            }
          }
        }
      }
    }

    // Account for the affinity.
    if (pick.getBestPhaseCode().equals(travelTime.getPhCode())) {
      observabilityAmp *= pick.getOriginalPhaseAffinity();

      if (LocUtil.deBugLevel > 2) {
        System.out.print(" Aff");
      }
    }

    // Make the existing identification harder to change.
    if (pick.getCurrentPhaseCode().equals(travelTime.getPhCode())) {
      observabilityAmp *= stickyWeight;

      if (LocUtil.deBugLevel > 2) {
        System.out.print(" Sticky");
      }
    }

    if (LocUtil.deBugLevel > 2) { 
      System.out.println("");
    }

    return observabilityAmp;
  }

  /**
   * This function computes the affinity weighted travel-time residual.
   *
   * @param pick A Pick object containing the pick information for one pick
   * @param travelTime A TTimeData object holding arrival time information for one 
   *              arrival
   * @return A double containing the affinity weighted residual
   */
  private double computeResidual(Pick pick, TTimeData travelTime) {
    if (pick.getBestPhaseCode().equals(travelTime.getPhCode())) {
      return Math.abs(pick.getTravelTime() - travelTime.getTT()) / pick.getOriginalPhaseAffinity();
    } else {
      return Math.abs(pick.getTravelTime() - travelTime.getTT()) / LocUtil.NULLAFFINITY;
    }
  }
}