package gov.usgs.locator;

import java.util.ArrayList;

/**
 * This class contains complete information (including auxiliary 
 * information) for all phases generated by a source at the desired 
 * depth and source receiver-distance.
 * 
 * @author Ray Buland
 *
 */
public class TTime {
	ArrayList<TTimeData> tTimes;
	
	/**
	 * The constructor just creates an ArrayList to hold the phase 
	 * data.
	 */
	public TTime() {
		tTimes = new ArrayList<TTimeData>();
	}
	
	/**
	 * Add basic travel time information for one phase.
	 * 
	 * @param phCode Phase code
	 * @param tt Travel time
	 * @param dTdD Derivative of time with respect to distance
	 * @param dTdZ Derivative of time with respect to depth
	 * @param dXdP Derivative of distance with respect to ray 
	 * parameter
	 */
	public void addPhase(String phCode, double tt, double dTdD, 
			double dTdZ, double dXdP) {
		tTimes.add(new TTimeData(phCode,tt,dTdD,dTdZ,dXdP));
	}
	
	/**
	 * Add phase statistical parameters.
	 * 
	 * @param spread Statistical spread
	 * @param observ Relative statistical observability
	 */
	public void addStats(double spread, double observ) {
		tTimes.get(tTimes.size()-1).addStats(spread, observ);
	}
	
	/**
	 * Add phase flags.
	 * 
	 * @param phGroup Base phase group
	 * @param auxGroup Auxiliary phase group
	 * @param isRegional True if this is a regional phase
	 * @param isDepth True if this is a depth phase
	 * @param canUse True if this phase can be used in an 
	 * earthquake location
	 * @param dis True if this phase should be down weighted 
	 * during phase identification
	 */
	public void addFlags(String phGroup, String auxGroup, 
			boolean isRegional, boolean isDepth, boolean canUse, 
			boolean dis) {
		tTimes.get(tTimes.size()-1).addFlags(phGroup, auxGroup, 
				isRegional, isDepth, canUse, dis);
	}
	
	/**
	 * Finalize the suite of travel times by sorting and 
	 * filtering them.
	 * 
	 * @param tectonic If true convert Pb and Sb into Pg and Sg
	 * @param noBackBrn If true eliminate all back branches
	 */
	public void finish(boolean tectonic, boolean noBackBrn) {
		//Sort the arrival times into increasing order.
		tTimes.sort(new ArrComp());
		// Filter the phases to make them easier to use.
		if(tectonic) TauUtil.filterTect(tTimes);
		if(noBackBrn) TauUtil.filterBack(tTimes);
		else TauUtil.filterDef(tTimes);
		// Modify the observabilities of phases closely following 
		// another phase in time.
		TauUtil.modObserv(tTimes);
		// Modify canUse for phases with no statistics.
		TauUtil.modCanUse(tTimes);
	}
	
	/**
	 * Provide a way of getting the number of phases found.
	 * 
	 * @return The number of phases in the list.
	 */
	public int size() {
		return tTimes.size();
	}
	
	/**
	 * Provide a way of getting the data for each phase by index.
	 * 
	 * @param i Phase index
	 * @return Travel-time structure
	 */
	public TTimeData get(int i) {
		return tTimes.get(i);
	}
	
	/**
	 * Print the travel-time data for all phases as a table.
	 * 
	 * @param depth Source depth in kilometers
	 * @param delta Source-receiver distance in degrees
	 */
	public void print(double depth, double delta) {
		System.out.println();
		System.out.format("Depth = %5.1f  Delta = %5.1f\n", depth, delta);
		if(tTimes.size() > 0) {
			for(int j=0; j<tTimes.size(); j++) {
				System.out.format("%2d  %s", j, tTimes.get(j));
			}
		} else {
			System.out.println("No arrival times found.");
		}
	}
}



/**
 * Helper class that contains everything known about one seismic 
 * phase at the desired source depth and source receiver distance.
 * 
 * @author Ray Buland
 *
 */
class TTimeData {
	String phCode;					// Phase code
	double tt;							// Travel time (s)
	double dTdD;						// Derivative of time with respect to 
													// distance (s/degree)
	double dTdZ;						// Derivative of time with respect to depth
													// (s/km)
	double dXdP;						// Derivative of distance with respect to 
													// ray parameter (degree-s)
	double spread;					// Statistical spread (s)
	double observ;					// Relative statistical observability
	String phGroup;					// Teleseismic phase group
	String auxGroup;				// Auxiliary phase group
	boolean isRegional;			// If true, phase is regional
	boolean isDepth;				// If true, phase is depth sensitive
	boolean canUse;					// If true, can use the phase for location
	boolean dis;						// Disrespect (down weight) this phase
	boolean corrTt;					// If true, correct the arrival time as well
	
	/**
	 * The constructor accepts basic travel time information.
	 * 
	 * @param phCode Phase code
	 * @param tt Travel time
	 * @param dTdD Derivative of time with respect to distance
	 * @param dTdZ Derivative of time with respect to depth
	 * @param dXdP Derivative of distance with respect to ray 
	 * parameter
	 */
	public TTimeData(String phCode, double tt, double dTdD, 
			double dTdZ, double dXdP) {
		this.phCode = phCode;
		this.tt = tt;
		this.dTdD = dTdD;
		this.dTdZ = dTdZ;
		this.dXdP = dXdP;
		corrTt = false;
	}
	
	/**
	 * Add phase statistical parameters.
	 * 
	 * @param spread Statistical spread
	 * @param observ Relative statistical observability
	 */
	public void addStats(double spread, double observ) {
		this.spread = spread;
		this.observ = observ;
	}
	
	/**
	 * Add phase flags.
	 * 
	 * @param phGroup Base phase group
	 * @param auxGroup Auxiliary phase group
	 * @param isRegional True if this is a regional phase
	 * @param isDepth True if this is a depth phase
	 * @param canUse True if this phase can be used in an 
	 * earthquake location
	 * @param dis True if this phase should be down weighted 
	 * during phase identification
	 */
	public void addFlags(String phGroup, String auxGroup, 
			boolean isRegional, boolean isDepth, boolean canUse, 
			boolean dis) {
		this.phGroup = phGroup;
		this.auxGroup = auxGroup;
		this.isRegional = isRegional;
		this.isDepth = isDepth;
		this.canUse = canUse;
		this.dis = dis;
	}
	
	/**
	 * Make arrival times sortable into time order.
	 * 
	 * @param arrival An travel-time data object.
	 * @return +1, 0, or -1 if arrival is later, the same time 
	 * or earlier
	 */
	public int compareTo(TTimeData arrival) {
		// Sort into arrival time order.
		if(this.tt < arrival.tt) return +1;
		else if(this.tt == arrival.tt) return 0;
		else return -1;
	}
	
	/**
	 * Return this arrival formatted similarly to the arrival 
	 * time list produced by the Locator version of Ttim.
	 */
	public String toString() {
		return String.format("%-8s %7.2f %10.2e %10.2e %5.2f %7.1f  "+
				"%-6s %-6s %-5b %-5b %-5b %-5b\n", phCode, tt, dTdD, 
				dTdZ, spread, observ, phGroup, auxGroup, isRegional, 
				isDepth, canUse, dis);
	}
}